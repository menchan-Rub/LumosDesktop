# LumosDesktop コーディング規約

## 1. 基本原則

### 1.1 コードの明瞭性と保守性
- 読みやすさを最優先し、自己文書化コードを目指す
- 複雑なロジックには適切なコメントを付ける
- 将来の拡張性を考慮した設計を心がける
- 「なぜそうしたか」を説明するコメントを重視する

### 1.2 パフォーマンスとリソース効率
- パフォーマンスクリティカルな部分は明確に文書化する
- メモリ使用量を常に意識する（特に最小要件環境での動作を考慮）
- 不必要なメモリ確保や計算を避ける
- バッテリー効率を考慮したコードを書く

### 1.3 エラー処理
- すべてのエラーを適切に処理し、未処理例外を発生させない
- エラーメッセージは具体的かつユーザーが理解できるものにする
- 回復可能なエラーと回復不可能なエラーを明確に区別する
- デバッグ情報はログに記録し、必要に応じてユーザーに表示する

### 1.4 セキュリティ
- 入力値は常に検証する
- 最小権限の原則に従う
- セキュリティに関わるコードは明確にマークし、レビューを重点的に行う
- 機密データの取り扱いには細心の注意を払う

## 2. 言語別ガイドライン

### 2.1 Rust

#### 2.1.1 コード構造
- モジュール構造は論理的な機能単位で分割する
- `pub` の使用は最小限に抑え、必要なインターフェースのみを公開する
- トレイトを活用して抽象化と再利用性を高める
- ジェネリクスは適切な場面で使用し、コードの重複を避ける

#### 2.1.2 型システムの活用
- 強力な型システムを活用してコンパイル時にエラーを捕捉する
- `Option<T>` と `Result<T, E>` を適切に使用する
- カスタム型を作成して意味のある型を定義する
- `unwrap()` や `expect()` の使用は最小限に抑え、適切なエラー処理を行う

#### 2.1.3 メモリ管理
- 所有権とライフタイムを明示的に考慮する
- 不必要なクローンを避ける
- `Rc<T>` や `Arc<T>` の使用は必要な場合のみに限定する
- 循環参照を避けるため、弱参照 (`Weak<T>`) を適切に使用する

#### 2.1.4 非同期処理
- `async/await` を一貫して使用する
- 長時間実行される処理は非同期化を検討する
- タスクのキャンセル機構を実装する
- スレッドプールのサイズとリソース使用量に注意を払う

#### 2.1.5 スタイル
- Rustの公式スタイルガイドに従う
- `rustfmt` を使用して一貫したフォーマットを維持する
- `clippy` を使用してコード品質を向上させる
- 命名規則：
  - 型とトレイト: `PascalCase`
  - 関数とメソッド: `snake_case`
  - 定数: `SCREAMING_SNAKE_CASE`
  - 変数とパラメータ: `snake_case`

### 2.2 C++

#### 2.2.1 コード構造
- モダンC++（C++17以上）の機能を活用する
- クラス階層は浅く保ち、継承よりコンポジションを優先する
- テンプレートの過剰な使用を避け、可読性を維持する
- ヘッダファイルの依存関係を最小化する

#### 2.2.2 メモリ管理
- 生ポインタの使用を避け、スマートポインタを使用する
- `std::unique_ptr` を優先し、共有所有権が必要な場合のみ `std::shared_ptr` を使用する
- RAII原則に従い、リソースリークを防止する
- メモリアロケーションを最小限に抑え、パフォーマンスクリティカルな部分ではカスタムアロケータを検討する

#### 2.2.3 エラー処理
- 例外は慎重に使用し、パフォーマンスクリティカルなパスでは避ける
- 例外安全性を確保する
- エラーコードと例外を一貫して使い分ける
- `noexcept` を適切に使用する

#### 2.2.4 スタイル
- Google C++ Style Guideをベースとするが、プロジェクト固有の要件に合わせて調整する
- `clang-format` を使用して一貫したフォーマットを維持する
- `clang-tidy` を使用してコード品質を向上させる
- 命名規則：
  - クラスと構造体: `PascalCase`
  - 関数とメソッド: `camelCase`
  - 変数: `snake_case`
  - 定数: `kConstantName`
  - マクロ（避けるべき）: `MACRO_NAME`

### 2.3 TypeScript

#### 2.3.1 コード構造
- 関数型プログラミングパラダイムを優先する
- クラスは状態管理が必要な場合のみ使用する
- モジュール分割を適切に行い、関心の分離を維持する
- インターフェースを活用して型安全性を確保する

#### 2.3.2 型システムの活用
- `any` 型の使用を避け、具体的な型を定義する
- ユニオン型とインターセクション型を適切に活用する
- ジェネリクスを使用して型の再利用性を高める
- `strictNullChecks` と `noImplicitAny` を有効にする

#### 2.3.3 非同期処理
- Promise chainingよりasync/awaitを優先する
- エラー処理を適切に行い、未処理のPromiseを残さない
- 非同期操作のキャンセル機構を実装する
- 並列処理には `Promise.all` を活用する

#### 2.3.4 スタイル
- Airbnb TypeScript Style Guideをベースとする
- ESLintとPrettierを使用して一貫したコードスタイルを維持する
- 命名規則：
  - クラスとインターフェース: `PascalCase`
  - 関数と変数: `camelCase`
  - 定数: `SCREAMING_SNAKE_CASE`
  - プライベートプロパティ: `_camelCase`

### 2.4 Python

#### 2.4.1 コード構造
- PEP 8に準拠する
- 関数型アプローチと手続き型アプローチを適切に組み合わせる
- クラスは明確な責任を持つように設計する
- モジュール構造は論理的な機能単位で分割する

#### 2.4.2 型ヒントの活用
- すべての関数とメソッドに型ヒントを付ける
- `mypy` を使用して静的型チェックを行う
- 複雑な型は `typing` モジュールを活用する
- ドキュメント文字列に型情報を含める

#### 2.4.3 パフォーマンス
- パフォーマンスクリティカルな部分では適切なデータ構造を選択する
- 大量のデータ処理には NumPy や Pandas などのライブラリを活用する
- メモリ使用量に注意し、ジェネレータを適切に活用する
- 計算集約的な処理は Rust や C++ で実装することを検討する

#### 2.4.4 スタイル
- PEP 8に従う
- `black` を使用して一貫したフォーマットを維持する
- `pylint` や `flake8` を使用してコード品質を向上させる
- 命名規則：
  - クラス: `PascalCase`
  - 関数と変数: `snake_case`
  - 定数: `SCREAMING_SNAKE_CASE`
  - プライベートメンバー: `_snake_case`

## 3. アーキテクチャガイドライン

### 3.1 モジュール設計
- 高凝集・低結合の原則に従う
- 明確に定義されたAPIを持つ独立したモジュールを作成する
- 循環依存を避ける
- プラグインアーキテクチャを活用して拡張性を確保する

### 3.2 UI/UX実装
- ビジネスロジックとUIを分離する（MVVMまたはMVCパターン）
- レスポンシブデザインを実装し、さまざまな画面サイズに対応する
- アクセシビリティを最初から考慮する
- UIスレッドをブロックしない

### 3.3 パフォーマンス最適化
- パフォーマンスのボトルネックを特定するためのプロファイリングを行う
- レンダリングパイプラインを最適化する
- メモリ使用量を監視し、リークを防止する
- バッテリー使用量を最小限に抑える

### 3.4 テスト戦略
- ユニットテスト、統合テスト、E2Eテストを適切に組み合わせる
- テスト駆動開発（TDD）を推奨する
- モックとスタブを活用して依存関係を分離する
- パフォーマンステストとメモリリークテストを自動化する

## 4. ドキュメンテーション

### 4.1 コードドキュメント
- パブリックAPIはすべて文書化する
- 複雑なアルゴリズムや設計決定の理由を説明する
- 言語固有のドキュメント生成ツールを活用する（Rustdoc, JSDoc, Sphinx等）
- 図表を活用して複雑な関係を説明する

### 4.2 アーキテクチャドキュメント
- システム全体のアーキテクチャ図を維持する
- モジュール間の依存関係を文書化する
- 設計決定とその理由を記録する
- アーキテクチャの進化を追跡する

### 4.3 ユーザードキュメント
- エンドユーザー向けドキュメントは明確で簡潔にする
- スクリーンショットやビデオを活用する
- 多言語対応を考慮する
- 定期的に更新し、最新の状態を維持する

## 5. コード品質管理

### 5.1 コードレビュー
- すべての変更はレビューを受ける
- レビューでは以下の点に注目する：
  - 機能性と正確性
  - パフォーマンスとリソース使用量
  - セキュリティ
  - コードの明瞭性と保守性
  - テストの適切さ
- 建設的なフィードバックを心がける

### 5.2 自動化されたチェック
- CI/CDパイプラインに以下を組み込む：
  - 静的解析ツール
  - リントツール
  - 自動テスト
  - パフォーマンスリグレッションテスト
  - セキュリティスキャン
- コードカバレッジを監視し、高い水準を維持する

### 5.3 リファクタリング
- 技術的負債を定期的に特定し、計画的に解消する
- リファクタリングは小さな単位で行い、機能変更と分離する
- リファクタリング前後でテストを実行し、動作の一貫性を確認する
- パフォーマンスへの影響を測定する

## 6. バージョン管理とリリース

### 6.1 ブランチ戦略
- GitFlow または GitHub Flow をベースとしたブランチ戦略を採用する
- 機能開発は個別のブランチで行う
- プルリクエストを通じてコードをメインブランチにマージする
- リリースブランチを使用して安定版を管理する

### 6.2 コミットメッセージ
- Conventional Commits 形式に従う
- 各コミットは単一の論理的変更を表す
- コミットメッセージは変更内容を明確に説明する
- 関連する課題番号を参照する

### 6.3 リリース管理
- セマンティックバージョニングを採用する
- 各リリースには詳細な変更履歴を含める
- リリース前に包括的なテストを実施する
- 段階的なロールアウト戦略を実装する

## 7. プラグイン開発ガイドライン

### 7.1 プラグインアーキテクチャ
- 明確に定義されたプラグインAPIを提供する
- プラグインはサンドボックス内で実行する
- リソース使用量を制限し、システムの安定性を確保する
- バージョン互換性を明示的に管理する

### 7.2 プラグイン品質基準
- プラグインはコアシステムと同じ品質基準に従う
- パフォーマンスへの影響を最小限に抑える
- ユーザーエクスペリエンスの一貫性を維持する
- セキュリティリスクを最小化する

### 7.3 プラグイン配布
- 検証済みプラグインのリポジトリを提供する
- プラグインのメタデータを標準化する
- ユーザーフィードバックと評価システムを実装する
- 自動更新メカニズムを提供する

## 8. アクセシビリティ要件

### 8.1 基本原則
- WCAG 2.2 AAレベル以上の準拠を目指す
- アクセシビリティをデザインと開発の初期段階から考慮する
- 定期的なアクセシビリティ監査を実施する
- ユーザーフィードバックを積極的に収集し改善に活かす

### 8.2 実装ガイドライン
- キーボードナビゲーションを完全にサポートする
- スクリーンリーダー対応を確保する
- 色のみに依存しない情報伝達を行う
- 十分なコントラスト比を確保する
- フォーカス可視性を明確にする
- 適切なARIA属性を使用する

### 8.3 テスト
- 自動化されたアクセシビリティテストを実施する
- 実際のアシスティブテクノロジーを使用した手動テストを行う
- 多様なユーザーによるユーザビリティテストを実施する
- アクセシビリティバグを優先的に修正する

## 9. 国際化と地域化

### 9.1 基本設計
- すべての文字列をリソースファイルに分離する
- Unicode処理を適切に行う
- 右から左へ書く言語（RTL）をサポートする
- 日付、時刻、数値、通貨のフォーマットを地域化する

### 9.2 実装ガイドライン
- ハードコードされた文字列を避ける
- 文字列連結による翻訳を避け、プレースホルダーを使用する
- 複数形ルールを適切に処理する
- 文化的に敏感な要素（色、アイコン、画像）に注意を払う

### 9.3 テスト
- 疑似翻訳テストを実施する
- 実際の翻訳者によるレビューを行う
- 様々な言語と地域設定でのUIテストを実施する
- 文字列の長さの違いによるレイアウトの問題を検証する

## 10. 持続可能性とウェルビーイング

### 10.1 省エネルギー設計
- バッテリー使用量を最小化するコードを書く
- バックグラウンド処理を最適化する
- 不要なネットワーク通信を避ける
- ハードウェアリソースの効率的な使用を促進する

### 10.2 デジタルウェルビーイング
- 長時間使用による視覚的疲労を軽減する設計を採用する
- 集中を妨げる不要な通知を最小限に抑える
- ユーザーの注意を尊重し、意図的な操作を促進する
- 健全な使用習慣を促進する機能を実装する

### 10.3 環境への配慮
- リソース使用量の可視化と最適化を行う
- 省エネルギーモードを実装する
- ハードウェア寿命を延ばす設計を採用する
- カーボンフットプリントを意識した設計決定を行う
